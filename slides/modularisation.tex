\section{Modularisierung}

\begin{frame}[fragile]{Aufteilung in Dateien}
	Projekte werden schnell zu groß für einzelne Dateien.
	
	\begin{block}{Wie fein unterteilen?}
		\begin{itemize}
			\item Eine Datei pro Funktion/Methode?
			\item Eine Datei pro Klasse?
			\item Eine Datei pro Namespace?
			\item Ganz anders?
		\end{itemize}
	\end{block}
\end{frame}

\begin{frame}[fragile]{Aufteilung in Dateien}
	\begin{block}{Faustregel}
		\begin{itemize}
			\item Namespaces entsprechen Ordnern
			\item Klassen entsprechen Dateien
			\item Gegebenenfalls zusätzliche Dateien für globale Makros
		\end{itemize}
	\end{block}
\end{frame}

\begin{frame}[fragile]{Source und Header}
	In C++ wird in der Regel zwischen Source-Dateien (.cpp) und Header-Dateien (.h oder .hpp) unterschieden.
	
	\begin{itemize}
		\item Header-Dateien enthalten Klassen- und Funktionsprototypen
		\item Source-Dateien enthalten die Implementierung dazu
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{Beispiel: Source und Header}
	\footnotesize
	
	
	\begin{columns}
		\column{0.4\textwidth}
		\emph{person.h}
		\vspace{0.5em}
		\lstinputlisting[language=C++, linerange={3-12}]{cpp-code/person.h}
		
		\column{0.4\textwidth}
		\emph{person.cpp}
		\vspace{0.5em}
		\lstinputlisting[language=C++]{cpp-code/person.cpp}
	\end{columns}
\end{frame}

\begin{frame}[fragile]{Inkludieren von Headern in Header}
	Freilich darf man auch in Header-Dateien \verb|#include|-Direktiven stehen haben. Man verwendet dies bspw., wenn man einen Typen in einem Header benötigt:
	
	\vspace{2em}
	
	\footnotesize
	\begin{columns}[t]
		\column{0.2\textwidth}
		\emph{pair.h}
		\vspace{0.5em}
		\lstinputlisting[language=C++, linerange={1-5}, tabsize=4]{cpp-code/header-inclusion.cpp}
		
		\uncover<2->
		{
			\column{0.3\textwidth}
			\emph{MyClass.h}
			\vspace{0.5em}
			\lstinputlisting[language=C++, linerange={8-15}, tabsize=4]{cpp-code/header-inclusion.cpp}
		}
		
		\uncover<3->
		{
			\column{0.3\textwidth}
			\emph{program.cpp}
			\vspace{0.5em}
			\lstinputlisting[language=C++, linerange=18, tabsize=4]{cpp-code/header-inclusion.cpp}
		}
	\end{columns}
\end{frame}

\begin{frame}{Include Guards}
	Lösung: in jedem Header ein Makro definieren, das anzeigt, ob die Datei schon eingebunden wurde.
	
	\vspace{1em}
	
	\footnotesize
	\begin{columns}[t]
		\column{0.2\textwidth}
		\emph{pair.h}
		\vspace{0.5em}
		\lstinputlisting[language=C++, linerange={1-10}, tabsize=4]{cpp-code/header-guards.cpp}
		
		\uncover<2->
		{
			\column{0.3\textwidth}
			\emph{MyClass.h}
			\vspace{0.5em}
			\lstinputlisting[language=C++, linerange={13-25}, tabsize=4]{cpp-code/header-guards.cpp}
		}
		
		\uncover<3->
		{
			\column{0.3\textwidth}
			\emph{program.cpp}
			\vspace{0.5em}
			\lstinputlisting[language=C++, linerange=28, tabsize=4]{cpp-code/header-guards.cpp}
		}
	\end{columns}
\end{frame}