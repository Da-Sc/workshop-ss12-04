\section{Übersetzungs-Phasen}


\subsection{Der Präprozessor}

\begin{frame}{Übersetzungs-Phasen (phases of translation)}
	Es gibt 9 Phasen der Übersetzung von Quellcode zum Programm:
	
	\vspace{2em}
	
	\begin{block}{phases of translation (Standard, 2.1)}
		\begin{enumerate}
			\item[3.] tokenizing
			\item<alert@2>[4.] preprocessing
			\item[7.] translation
			\item<alert@2>[9.] linking
		\end{enumerate}
	\end{block}
\end{frame}

\begin{frame}[fragile]{Präprozessor}
	Der Präprozessor arbeitet auf der Basis von Tokens, also auf Textausdrücken. Er führt auf dieser Basis folgende Operationen aus:
	
	\vspace{2em}
	
	\begin{itemize}
		\item Einfügen von Dateiinhalten \verb|#include| (diese werden neu übersetzt!)
		\item Suchen \& Ersetzen \verb|#define|
		\item Bedingtes Einfügen \verb|#if|
		\item Abbrechen der Übersetzung \verb|#error|
	\end{itemize}
\end{frame}

\begin{frame}[fragile]{Zusammenhang mit der Übersetzung}
	\begin{itemize}
		\item Der Präprozessor wird durch Direktiven (Anweisungen) innerhalb des Quellcodes programmiert.
		\item Präprozessor-Direktiven stehen in einer eigenen Zeile und beginnen mit einem \verb|#|
		\item Die Quellcode-Dateien dienen zugleich als Eingabe für den Präprozessor. Die Ausgabe geht dann in die nächste Übersetzungsphase.
	\end{itemize}
	
	\pause
	\vspace{1em}
	
	Eine Datei ohne Präprozessor-Anweisungen oder auch nur ein Dateiabschnitt, der nicht von Anweisungen betroffen ist, geht unverändert von Eingabe zu Ausgabe.
\end{frame}

\begin{frame}[fragile]{Die include-Direktive}
	\begin{block}{include-Direktive}
		\verb|#include "|\emph{dateiname}\verb|"| \\
		\vspace{0.5em}
		ersetzt diese Zeile durch den Inhalt der Datei \emph{dateiname}. \\
		Der Inhalt der Datei wandert durch die Phasen 1-4 bevor mit dem Preprocessing fortgefahren wird.
	\end{block}
	
	\pause
	\vspace{1em}
	
	Es gibt noch die Variante \verb|#include <|\emph{headername}\verb|>|, diese ist für Header-Dateien aus der Standard-Bibliothek gedacht. Gängige Compiler/Preprocessors behandeln beide Varianten ähnlich, es werden jedoch die Suchpfade für \emph{headername} gegenüber der ersten Variante verändert.
\end{frame}

\begin{frame}{Beispiel: include}
	\footnotesize
	
	\begin{columns}
		\column{0.4\textwidth}
		\emph{my-header.h}
		\lstinputlisting[language=C++, linerange={1-4}]{cpp-code/include-directive.cpp}
		
		\column{0.4\textwidth}
		\lstinputlisting[language=C++, linerange={7-12}]{cpp-code/include-directive.cpp}
	\end{columns}
\end{frame}

\begin{frame}[fragile]{Die define-Direktive}
	\begin{block}{define-Direktive}
		\verb|#define NAME TOKEN0 TOKEN1.....| \\
		\vspace{0.5em}
		Definiert ein (object-like) Macro mit dem Namen \verb|NAME|, die darauf folgenden Token sind optional. Trifft der Präprozessor nach der Definition eines Macros auf das Token \verb|NAME|, so ersetzt er es durch die Token \verb|TOKEN0 TOKEN1....|.
	\end{block}
\end{frame}

\begin{frame}{Beispiel: define-Direktive}
	\footnotesize
	\lstinputlisting[language=C++]{cpp-code/define-directive.cpp}
\end{frame}

\begin{frame}[fragile]{Bedingtes Einfügen}
	\begin{block}{if-, else- und endif-Direktiven}
		\begin{lstlisting}[language=C++]
			#if constant_expression_0
			// (0)
			#else
			// (1)
			#endif
		\end{lstlisting}
		Die Kommentare (0) usw. stehen für jeweils optional mehrere Zeilen Code.
		Dann wird durch den Präprozessor entweder die Zeilen (0) oder (1) in seine Ausgabe (für die weitere Übersetzung) eingefügt. Was eingefügt wird, ist abhängig vom Wert von \verb|constant_expression_0|.
	\end{block}
\end{frame}

\begin{frame}{Beispiel: Bedingtes Einfügen}
	\footnotesize
	\lstinputlisting[language=C++]{cpp-code/conditional-inclusion.cpp}
\end{frame}




\subsection{Der Linker}

\begin{frame}[fragile]{Die translation unit}
	Beim Übersetzen werden bis auf den letzten Schritt die Eingabedateien (.cpp, .cc) unabhängig / getrennt voneinander behandelt.
	
	Der Präprozessor arbeite nun auf einer .cpp-Datei. Er fügt dann Weiteres ein bzw. ersetzt (\verb|#include|, \verb|#define|) und lässt manches aus (\verb|#if|, \verb|#else|).
	
	\vspace{1em}
	
	\begin{block}{translation unit}
		Die Ausgabe des Präprozessors ist dann also die source file (.cpp) plus alle eingebundenen Dateien abzüglich den Auslassungen und mit den Macro-Ersetzungen.\\
		Das Entstandene nennt man \emph{translation unit}.
	\end{block}
\end{frame}

\begin{frame}{Linkage}
	Eine translation unit wird dann in der 7. Phase der Übersetzung tatsächlich \emph{übersetzt}, also kompilliert.
	
	\vspace{1em}
	
	\begin{block}{linkage (Standard, 3.5:2)}
		Hat in einer translation unit der Name eines »Dinges«, Referenz, Funktion, Typ, template oder namespace \emph{external linkage}, so darf auf das Etwas, das der Name benennt, auch in anderen translation units zugegriffen werden.
	\end{block}
	Im Normalfall hat ein Name in einem namespace (also nicht innerhalb einer Klassen oder Funktion) external linkage.
	
	\vspace{1em}
	\pause
	
	Aber: Da zuvor in der 7. Phase schon kompilliert wird, muss dem Compiler gesagt werden, dass dieses Etwas überhaupt existiert.\\
	\tiny
	Siehe: \url{https://github.com/downloads/kit-cpp-workshop/workshop-ss12-03/addendum-header.pdf}
\end{frame}

\begin{frame}{Beispiel: external linkage}
	\footnotesize
	\begin{columns}[t]
		\column{0.4\textwidth}
		translation unit \emph{square.cpp}
		\vspace{1em}
		\lstinputlisting[language=C++, linerange={1-4}]{cpp-code/linkage.cpp}
		
		\pause
		
		\column{0.4\textwidth}
		translation unit \emph{main.cpp}
		\vspace{1em}
		\lstinputlisting[language=C++, linerange={7-12}]{cpp-code/linkage.cpp}
	\end{columns}
\end{frame}

\begin{frame}{Klassen und Linkage}
	member functions von Klassen (Methoden) sind auch nur Funktionen, d.h. sie dürfen auch in anderen translation units verwendet werden.
	
	Dem Namen einer Klassen selbst schreibt man auch linkage zu. Hat der Name einer Klasse external linkage, so bedeutet dies nur, dass die Namen der member functions external linkage haben.
	
	\pause
	\vspace{1em}
	
	\footnotesize
	\begin{columns}[t]
		\column{0.4\textwidth}
		translation unit \emph{square.cpp}
		\vspace{1em}
		\lstinputlisting[language=C++, linerange={15-23}]{cpp-code/linkage.cpp}
		
		\pause
		\column{0.4\textwidth}
		translation unit \emph{main.cpp}
		\vspace{1em}
		\lstinputlisting[language=C++, linerange={15-18, 25-30}]{cpp-code/linkage.cpp}
	\end{columns}
\end{frame}

\begin{frame}[fragile]{Linkage-Modifier}
	Im Normalfall hat ein Name in einem namespace (also nicht innerhalb einer Klassen oder Funktion) external linkage.
	
	\vspace{1em}
	
	Man kann die Linkage durch die Schlüsselwörter \verb|extern| und \verb|static| sowie durch unbenannte namespaces beeinflussen:
	
	\pause
	
	\begin{block}{static im Bezug auf Linkage}
		Schreibt man vor die Definition eines »Dinges«, einer Referenz oder einer Funktion \verb|static|, so hat der Name \emph{internal linkage}.
	\end{block}
	
	\pause
	
	\begin{block}{unnamed namespaces}
		Alles innerhalb eines unbenannten namespaces \verb|namespace { /*...*/ }| hat erst einmal \emph{internal linkage}. Dies \enquote{vererbt} sich bspw. auf alle darinnen deklarierten Funktionen.
	\end{block}
\end{frame}

\begin{frame}{Beispiel: Linkage-Modifier}
	\footnotesize
	\alt<2>
	{% on slide 1
		\lstinputlisting[language=C++, tabsize=4]{cpp-code/linkage-modifiers.cpp}
	}{% on slide 2
		\lstinputlisting[language=C++, tabsize=4, commentstyle=\none]{cpp-code/linkage-modifiers.cpp}
	}
\end{frame}
